Message format.

message_id = sha256(message)

message {
    char    message_ver Message version.

    int64   pow         Integer such that sha256(message_ver + timestamp + sha256(data) + pow)
                        starts with at least 20 0 bits.

                        The inner sha256(data) is to make the time to calculate a POW constant, not
                        depending on the length of data[].


    int64   timestamp   Signed integer value denoting seconds past epoch.

    char[]  data        Message data. Strictly speaking can be anything, but
                        is usually GPG encrypted data.
}

Header format

message_header {
    int64    timestamp   Timestamp, signed int.
    int64    size        Size of message (Full message including metadata, in bytes)
    char[32] message_id  sha256(message)
}


Syncing format

The client will work with any URL that supports GET and PUT requests. Files are stored as their
message ID as their name. The plain message ID is used, but servers are encouraged to use a scheme
that allows thousands of files to exist and be addressed quickly. One such scheme is to put a slash
after the first 2 characters to avoid too many files being put in the same directory. Another idea
is using SQLite to have just 1 file.

Apart from messages being stored as that, there must also be an "index" file. This will consist of
all the message headers that exist, and will help the client quickly determine which hashes it
should upload or download.
