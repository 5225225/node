Message format.

message_id = sha256(message)

message {
    char    message_ver Message version.

    int64   pow         Integer such that sha256(message_ver + timestamp + sha256(data) + pow)
                        starts with at least 20 0 bits.

                        The inner sha256(data) is to make the time to calculate a POW constant, not
                        depending on the length of data[].


    int64   timestamp   Signed integer value denoting seconds past epoch.

    char[]  data        Message data. Strictly speaking can be anything, but
                        is usually GPG encrypted data.
}

Header format

message_header {
    int64    timestamp   Timestamp, signed int.
    int64    size        Size of message (Full message including metadata, in bytes)
    char[32] message_id  sha256(message)
}


Syncing format

The client will work with any URL that supports GET and PUT requests. Files are stored as their
message ID as their name. The plain message ID is used, but servers are encouraged to use a scheme
that allows thousands of files to exist and be addressed quickly. One such scheme is to put a slash
after the first 2 characters to avoid too many files being put in the same directory. Another idea
is using SQLite to have just 1 file.

Apart from messages being stored as that, there must also be an "index" file. This will consist of
all the message headers that exist, and will help the client quickly determine which hashes it
should upload or download.


    Syncing

syncd: Takes a list of URLs to sync from. Calls do_sync on each URL in turn.
       Manages delays between syncing, random selection of URLs, automatic syncing when a new
       message is written.

    do_sync: Takes a URL and reads it's index. Calculates, using the local message dir, which
             messages needs to be GET/PUT. Runs do_get, do_put with their message_id as an argument

        net_get: Takes a (URL, id) and downloads that message, piping to stdout.

        net_put: Takes a (URL, id(?)) and uploads from stdin. The id is verified.

msgdir_put: Takes a message from stdin, puts in a message dir.

msgdir_get: Takes a id. Pipes message to stdout.

make_msg: Takes a file from stdin and generates a message for it.
          Fills in message_ver, pow, timestamp.

split_msg: Takes a message from stdin and splits the data part out of it.
           Checks POW, version. Outputs timestamp (ISO with second precision), then a newline, then
           the message.
           
           This is lossless since `head -n1 message > date` will always return the date portion,
           since it contains no newlines. `tail -n+1 message > data` will always return the data
           portion, since it will skip the date portion entirely. It does not matter what the data
           portion contains.

serve_files: Implements a server which allows you to GET/PUT files.

client: Handles the UI. 

    write_msg: When invoked, starts $EDITOR and allows you to write a text file.
               Then pipes this to make_msg, then inserts that message into the message dir with
               msgdir_put.

    read_msg: Takes a message ID and gets the data from msgdir_get. 


gen_index: Takes a message on stdin and generates an index file for it.

diff_index: Takes 2 index files (As arguments), and generates a series of commands needed to sync.
            Output takes the form `./msgdir_get <id> | ./net_put <url> <id>` to upload
                              and `./net_get <url> <id> | ./msgdir_put`      to download
            This way you can simply execute the file in full to sync.
